#include "initramfs.h"
#include "uart.h"
#include "mm.h"
#include "string.h"
#include "initrd.h"

#ifndef DEFAULT_INODE_SIZE
#define DEFAULT_INODE_SIZE             (4096)
#endif

int initramfs_setup_mount(struct filesystem* fs, struct mount* mount);

int initramfs_write(struct file *file, const void *buf, size_t len);
int initramfs_read(struct file *file, void *buf, size_t len);
int initramfs_open(struct vnode *file_node, struct file **target);
int initramfs_close(struct file *file);
long initramfs_lseek64(struct file *file, long offset, int whence);

int initramfs_lookup(struct vnode *dir_node, struct vnode **target, const char *component_name);
int initramfs_create(struct vnode *dir_node, struct vnode **target, const char *component_name);
int initramfs_mkdir(struct vnode *dir_node, struct vnode **target, const char *component_name);

struct filesystem initramfs_filesystem = {
    .name = "initramfs",
    .setup_mount = initramfs_setup_mount,
};

struct file_operations initramfs_file_operations = {
    .write   = initramfs_write,
    .read    = initramfs_read,
    .open    = initramfs_open,
    .close   = initramfs_close,
    .lseek64 = initramfs_lseek64,
};

struct vnode_operations initramfs_vnode_operations = {
    .lookup  = initramfs_lookup,
    .create  = initramfs_create,
    .mkdir   = initramfs_mkdir,
};

int initramfs_setup_mount(struct filesystem* fs, struct mount* mount)
{
#ifdef VFS_DEBUG
    printf("        [initramfs_setup_mount]\n");
#endif

    mount->fs = fs;
    mount->root = initramfs_create_vnode(0, FSNODE_TYPE_DIR);

    /* Iterate .cpio and add all files to initramfs file system */
    initramfs_init(mount->root->internal);

    return 1;
}

/**
 * Create a initramfs vnode along with the inode below it.
 * We should specify the type of the vnode and the mount structure of it.
 */
struct vnode *initramfs_create_vnode(struct mount *mount, enum fsnode_type type)
{
    struct vnode *node;
    struct initramfs_inode *inode;

    /* Create vnode */
    node = (struct vnode*)kmalloc(sizeof(struct vnode));
    node->v_ops = &initramfs_vnode_operations;
    node->f_ops = &initramfs_file_operations;
    node->mount = mount; // All the vnode should not point back to mount.

    /* Create initramfs inode */
    inode = (struct initramfs_inode *)kmalloc(sizeof(struct initramfs_inode));
    memset(inode, 0, sizeof(struct initramfs_inode));
    inode->type = type;
    inode->data = (char *)kmalloc(DEFAULT_INODE_SIZE);

    /* Assign inode to vnode */
    node->internal = inode;
    return node;
}

/* should fail */
int initramfs_write(struct file *file, const void *buf, size_t len)
{
    return 0;
}

/* File read operation */
int initramfs_read(struct file *file, void *buf, size_t len)
{
    struct initramfs_inode *inode;

    inode = file->vnode->internal;
    /*if buffer overflow, shrink the request read length. Then read from f_pos */
    if ((file->f_pos + len) > inode->data_size) {
        len = inode->data_size - file->f_pos;
        memcpy(buf, inode->data + file->f_pos, len);
        file->f_pos += inode->data_size - file->f_pos;
    } else {
        memcpy(buf, inode->data + file->f_pos, len);
        file->f_pos += len;
    }
    return len;
}

/* Newly created struct file should be generated by file_vnode. */
int initramfs_open(struct vnode *file_node, struct file **target)
{
    (*target)->vnode = file_node;
    (*target)->f_ops = file_node->f_ops;
    (*target)->f_pos = 0;
    return 1;
}

/* file close opeation. Just free the memory */
int initramfs_close(struct file *file)
{
    kfree(file);
    return 1;
}

/* Move the f_pos of the struct file. */
long initramfs_lseek64(struct file *file, long offset, int whence)
{
    if (whence == SEEK_SET) {
        file->f_pos = offset;
        return file->f_pos;
    }
    return 0;
}

/**
 * initramfs vnode operations, lookup all the vnodes under dir_node.
 * Returns 0 if error, returns 1 if success.
 */
int initramfs_lookup(struct vnode *dir_node, struct vnode **target, const char *component_name)
{
    struct initramfs_inode *dir_inode, *inode;
    struct vnode *vnode;
    int child_idx;

    /* Search the child inode. */
    dir_inode = dir_node->internal;
    for (child_idx = 0; child_idx < MAX_DIR_NUM; child_idx++) {
        vnode = dir_inode->childs[child_idx];
        if (!vnode)
            break;
        inode = vnode->internal;
        if (!strcmp(component_name, inode->name)) {
            *target = vnode;
            return 1;
        }
    }
    printf("        [initramfs_lookup] %s not found\n", component_name);
    return 0;
}

/* initramfs vnode operation: should fail */
int initramfs_create(struct vnode *dir_node, struct vnode **target, const char *component_name)
{
    return 0;
}

/* vnode operation: should fail */
int initramfs_mkdir(struct vnode *dir_node, struct vnode **target, const char *component_name)
{
    return 0;
}